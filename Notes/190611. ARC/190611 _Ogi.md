
주어진 자원을 효율적으로 사용하여 최대의 아웃풋을 내는 것.

reference Counting : 필요한 동안만 메모리에 있도록 하자.
해당 instance를 필요로 하는 얘들의 숫자를 세자.
해당 instance를 참조하면 count + 1
자동으로 counting 을 해주기 때문에 automatic 을 붙여서 arc !


MRC를 사용하여 수동으로 코드 할 수 있는데 왜 ARC를 사용하니 ?
mrc의 단점 : 코드의 복잡도가 증가한다.
개발자가 메모리 관리에 신경쓰면 집중도 떨어짐
앱 승인 대부분이 메모리 관리가 안되어 갑자기 닫히는 그런 것으로 reject 된다.
서로 참조하는 메모리가 살아있는 수명 시간에 대해 고려해보아야 한다.




프로퍼티가 상수 또는 변수에 클래스의 인스턴스를 할당할 때 '강한참조'라고 한다.
강한참조가 되어있으면 해당 생성자를 삭제하여도 참조카운트가 남아있다.
새로운 변수에 새로운 참조를 하게 된다면 count가 1, 2, 3으로 늘어나는게 아닌
1, 1, 1 과 같이 새롭게 참조 카운트가 된다.


강한참조 순환이 발생되지 않게 하기 위한 두가지 방법

1. 약한 참조를 사용하여 참조를 하여도 카운팅을 하지 않는다.
변수로 선언하여 nil로 바뀔 수 있는 상황을 생각하여 상수가 아닌 변수로 선언한다.

2. unowned 미소유 참조


garbage collecter 와 ARC의 차이
:
garbage collector는 메모리 전체를 파악하기 때문에 속도가 느려진다. 
메모리를 헤집고 다니면서 메모리안의 객체가 앞으로 쓰일 수 있는지 아닌지를 실시간으로 계속하여 찾아내기 때문에 속도가 느려진다. -> 자원낭비

MRC나 ARC : 메모리 관리를 컴파일러단에서 한다. 

ARC의 단점: 프로그래머가 메모리 관리 기법에 대해 이해를 하지 못한 상태에서 코드를 작성해 놓으면 영원히 메모리에서 사라지지 않을 가능성이 있다.
메모리에서 해제시키고 싶은데 강한 참조 순환처럼 특정 변수에 nil을 할당해버리면 코드로 참조할 수 없고 arc 카운트가 1이 되어서 .. 계속 좀비처럼 남게 되는 상황 

클로저는 이 코드를 나중에 쓸 거니까 변수에 담아둬 ~ 라고 하는 블럭.
변수에 담아두는 것

객체를 나중에 써야하니까 미리 카운팅을 해놓는다.




MUST TODO  !
1. reference type에 의해 value 관리
:  

2. retain이란 ?
